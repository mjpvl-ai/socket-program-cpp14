// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
class ClientMessage;
struct ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class DeregistrationAck;
struct DeregistrationAckDefaultTypeInternal;
extern DeregistrationAckDefaultTypeInternal _DeregistrationAck_default_instance_;
class DeregistrationRequest;
struct DeregistrationRequestDefaultTypeInternal;
extern DeregistrationRequestDefaultTypeInternal _DeregistrationRequest_default_instance_;
class PduSessionAck;
struct PduSessionAckDefaultTypeInternal;
extern PduSessionAckDefaultTypeInternal _PduSessionAck_default_instance_;
class PduSessionRequest;
struct PduSessionRequestDefaultTypeInternal;
extern PduSessionRequestDefaultTypeInternal _PduSessionRequest_default_instance_;
class RegistrationAck;
struct RegistrationAckDefaultTypeInternal;
extern RegistrationAckDefaultTypeInternal _RegistrationAck_default_instance_;
class RegistrationRequest;
struct RegistrationRequestDefaultTypeInternal;
extern RegistrationRequestDefaultTypeInternal _RegistrationRequest_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ClientMessage* Arena::CreateMaybeMessage<::ClientMessage>(Arena*);
template<> ::DeregistrationAck* Arena::CreateMaybeMessage<::DeregistrationAck>(Arena*);
template<> ::DeregistrationRequest* Arena::CreateMaybeMessage<::DeregistrationRequest>(Arena*);
template<> ::PduSessionAck* Arena::CreateMaybeMessage<::PduSessionAck>(Arena*);
template<> ::PduSessionRequest* Arena::CreateMaybeMessage<::PduSessionRequest>(Arena*);
template<> ::RegistrationAck* Arena::CreateMaybeMessage<::RegistrationAck>(Arena*);
template<> ::RegistrationRequest* Arena::CreateMaybeMessage<::RegistrationRequest>(Arena*);
template<> ::ServerMessage* Arena::CreateMaybeMessage<::ServerMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MessageType : int {
  REGISTRATION_REQUEST = 0,
  REGISTRATION_ACK = 1,
  PDU_SESSION_REQUEST = 2,
  PDU_SESSION_ACK = 3,
  DEREGISTRATION_REQUEST = 4,
  DEREGISTRATION_ACK = 5,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = REGISTRATION_REQUEST;
constexpr MessageType MessageType_MAX = DEREGISTRATION_ACK;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class RegistrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegistrationRequest) */ {
 public:
  inline RegistrationRequest() : RegistrationRequest(nullptr) {}
  ~RegistrationRequest() override;
  explicit PROTOBUF_CONSTEXPR RegistrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistrationRequest(const RegistrationRequest& from);
  RegistrationRequest(RegistrationRequest&& from) noexcept
    : RegistrationRequest() {
    *this = ::std::move(from);
  }

  inline RegistrationRequest& operator=(const RegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationRequest& operator=(RegistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const RegistrationRequest*>(
               &_RegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegistrationRequest& a, RegistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistrationRequest& from) {
    RegistrationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegistrationRequest";
  }
  protected:
  explicit RegistrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RegistrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class RegistrationAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegistrationAck) */ {
 public:
  inline RegistrationAck() : RegistrationAck(nullptr) {}
  ~RegistrationAck() override;
  explicit PROTOBUF_CONSTEXPR RegistrationAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistrationAck(const RegistrationAck& from);
  RegistrationAck(RegistrationAck&& from) noexcept
    : RegistrationAck() {
    *this = ::std::move(from);
  }

  inline RegistrationAck& operator=(const RegistrationAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationAck& operator=(RegistrationAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistrationAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistrationAck* internal_default_instance() {
    return reinterpret_cast<const RegistrationAck*>(
               &_RegistrationAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegistrationAck& a, RegistrationAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrationAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistrationAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistrationAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistrationAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistrationAck& from) {
    RegistrationAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrationAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegistrationAck";
  }
  protected:
  explicit RegistrationAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageFieldNumber = 3,
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string status_message = 3;
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RegistrationAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
    int32_t id_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PduSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PduSessionRequest) */ {
 public:
  inline PduSessionRequest() : PduSessionRequest(nullptr) {}
  ~PduSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR PduSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PduSessionRequest(const PduSessionRequest& from);
  PduSessionRequest(PduSessionRequest&& from) noexcept
    : PduSessionRequest() {
    *this = ::std::move(from);
  }

  inline PduSessionRequest& operator=(const PduSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PduSessionRequest& operator=(PduSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PduSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PduSessionRequest* internal_default_instance() {
    return reinterpret_cast<const PduSessionRequest*>(
               &_PduSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PduSessionRequest& a, PduSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PduSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PduSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PduSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PduSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PduSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PduSessionRequest& from) {
    PduSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PduSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PduSessionRequest";
  }
  protected:
  explicit PduSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdFieldNumber = 4,
    kIdFieldNumber = 1,
    kPduIdFieldNumber = 2,
    kSstFieldNumber = 3,
  };
  // string sd = 4;
  void clear_sd();
  const std::string& sd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sd();
  PROTOBUF_NODISCARD std::string* release_sd();
  void set_allocated_sd(std::string* sd);
  private:
  const std::string& _internal_sd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sd(const std::string& value);
  std::string* _internal_mutable_sd();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 pdu_id = 2;
  void clear_pdu_id();
  int32_t pdu_id() const;
  void set_pdu_id(int32_t value);
  private:
  int32_t _internal_pdu_id() const;
  void _internal_set_pdu_id(int32_t value);
  public:

  // int32 sst = 3;
  void clear_sst();
  int32_t sst() const;
  void set_sst(int32_t value);
  private:
  int32_t _internal_sst() const;
  void _internal_set_sst(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PduSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sd_;
    int32_t id_;
    int32_t pdu_id_;
    int32_t sst_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PduSessionAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PduSessionAck) */ {
 public:
  inline PduSessionAck() : PduSessionAck(nullptr) {}
  ~PduSessionAck() override;
  explicit PROTOBUF_CONSTEXPR PduSessionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PduSessionAck(const PduSessionAck& from);
  PduSessionAck(PduSessionAck&& from) noexcept
    : PduSessionAck() {
    *this = ::std::move(from);
  }

  inline PduSessionAck& operator=(const PduSessionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline PduSessionAck& operator=(PduSessionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PduSessionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const PduSessionAck* internal_default_instance() {
    return reinterpret_cast<const PduSessionAck*>(
               &_PduSessionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PduSessionAck& a, PduSessionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(PduSessionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PduSessionAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PduSessionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PduSessionAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PduSessionAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PduSessionAck& from) {
    PduSessionAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PduSessionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PduSessionAck";
  }
  protected:
  explicit PduSessionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageFieldNumber = 4,
    kIdFieldNumber = 1,
    kPduIdFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string status_message = 4;
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 pdu_id = 2;
  void clear_pdu_id();
  int32_t pdu_id() const;
  void set_pdu_id(int32_t value);
  private:
  int32_t _internal_pdu_id() const;
  void _internal_set_pdu_id(int32_t value);
  public:

  // int32 status = 3;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PduSessionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
    int32_t id_;
    int32_t pdu_id_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class DeregistrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeregistrationRequest) */ {
 public:
  inline DeregistrationRequest() : DeregistrationRequest(nullptr) {}
  ~DeregistrationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeregistrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregistrationRequest(const DeregistrationRequest& from);
  DeregistrationRequest(DeregistrationRequest&& from) noexcept
    : DeregistrationRequest() {
    *this = ::std::move(from);
  }

  inline DeregistrationRequest& operator=(const DeregistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregistrationRequest& operator=(DeregistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregistrationRequest* internal_default_instance() {
    return reinterpret_cast<const DeregistrationRequest*>(
               &_DeregistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeregistrationRequest& a, DeregistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregistrationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregistrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregistrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregistrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregistrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeregistrationRequest& from) {
    DeregistrationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregistrationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeregistrationRequest";
  }
  protected:
  explicit DeregistrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DeregistrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class DeregistrationAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeregistrationAck) */ {
 public:
  inline DeregistrationAck() : DeregistrationAck(nullptr) {}
  ~DeregistrationAck() override;
  explicit PROTOBUF_CONSTEXPR DeregistrationAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregistrationAck(const DeregistrationAck& from);
  DeregistrationAck(DeregistrationAck&& from) noexcept
    : DeregistrationAck() {
    *this = ::std::move(from);
  }

  inline DeregistrationAck& operator=(const DeregistrationAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregistrationAck& operator=(DeregistrationAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregistrationAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregistrationAck* internal_default_instance() {
    return reinterpret_cast<const DeregistrationAck*>(
               &_DeregistrationAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeregistrationAck& a, DeregistrationAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregistrationAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregistrationAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregistrationAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregistrationAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregistrationAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeregistrationAck& from) {
    DeregistrationAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregistrationAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeregistrationAck";
  }
  protected:
  explicit DeregistrationAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageFieldNumber = 3,
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string status_message = 3;
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DeregistrationAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
    int32_t id_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientMessage) */ {
 public:
  inline ClientMessage() : ClientMessage(nullptr) {}
  ~ClientMessage() override;
  explicit PROTOBUF_CONSTEXPR ClientMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMessage(const ClientMessage& from);
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kRegReq = 2,
    kPduReq = 3,
    kDeregReq = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientMessage& from) {
    ClientMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientMessage";
  }
  protected:
  explicit ClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kRegReqFieldNumber = 2,
    kPduReqFieldNumber = 3,
    kDeregReqFieldNumber = 4,
  };
  // .MessageType type = 1;
  void clear_type();
  ::MessageType type() const;
  void set_type(::MessageType value);
  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);
  public:

  // .RegistrationRequest reg_req = 2;
  bool has_reg_req() const;
  private:
  bool _internal_has_reg_req() const;
  public:
  void clear_reg_req();
  const ::RegistrationRequest& reg_req() const;
  PROTOBUF_NODISCARD ::RegistrationRequest* release_reg_req();
  ::RegistrationRequest* mutable_reg_req();
  void set_allocated_reg_req(::RegistrationRequest* reg_req);
  private:
  const ::RegistrationRequest& _internal_reg_req() const;
  ::RegistrationRequest* _internal_mutable_reg_req();
  public:
  void unsafe_arena_set_allocated_reg_req(
      ::RegistrationRequest* reg_req);
  ::RegistrationRequest* unsafe_arena_release_reg_req();

  // .PduSessionRequest pdu_req = 3;
  bool has_pdu_req() const;
  private:
  bool _internal_has_pdu_req() const;
  public:
  void clear_pdu_req();
  const ::PduSessionRequest& pdu_req() const;
  PROTOBUF_NODISCARD ::PduSessionRequest* release_pdu_req();
  ::PduSessionRequest* mutable_pdu_req();
  void set_allocated_pdu_req(::PduSessionRequest* pdu_req);
  private:
  const ::PduSessionRequest& _internal_pdu_req() const;
  ::PduSessionRequest* _internal_mutable_pdu_req();
  public:
  void unsafe_arena_set_allocated_pdu_req(
      ::PduSessionRequest* pdu_req);
  ::PduSessionRequest* unsafe_arena_release_pdu_req();

  // .DeregistrationRequest dereg_req = 4;
  bool has_dereg_req() const;
  private:
  bool _internal_has_dereg_req() const;
  public:
  void clear_dereg_req();
  const ::DeregistrationRequest& dereg_req() const;
  PROTOBUF_NODISCARD ::DeregistrationRequest* release_dereg_req();
  ::DeregistrationRequest* mutable_dereg_req();
  void set_allocated_dereg_req(::DeregistrationRequest* dereg_req);
  private:
  const ::DeregistrationRequest& _internal_dereg_req() const;
  ::DeregistrationRequest* _internal_mutable_dereg_req();
  public:
  void unsafe_arena_set_allocated_dereg_req(
      ::DeregistrationRequest* dereg_req);
  ::DeregistrationRequest* unsafe_arena_release_dereg_req();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ClientMessage)
 private:
  class _Internal;
  void set_has_reg_req();
  void set_has_pdu_req();
  void set_has_dereg_req();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::RegistrationRequest* reg_req_;
      ::PduSessionRequest* pdu_req_;
      ::DeregistrationRequest* dereg_req_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kRegAck = 2,
    kPduAck = 3,
    kDeregAck = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kRegAckFieldNumber = 2,
    kPduAckFieldNumber = 3,
    kDeregAckFieldNumber = 4,
  };
  // .MessageType type = 1;
  void clear_type();
  ::MessageType type() const;
  void set_type(::MessageType value);
  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);
  public:

  // .RegistrationAck reg_ack = 2;
  bool has_reg_ack() const;
  private:
  bool _internal_has_reg_ack() const;
  public:
  void clear_reg_ack();
  const ::RegistrationAck& reg_ack() const;
  PROTOBUF_NODISCARD ::RegistrationAck* release_reg_ack();
  ::RegistrationAck* mutable_reg_ack();
  void set_allocated_reg_ack(::RegistrationAck* reg_ack);
  private:
  const ::RegistrationAck& _internal_reg_ack() const;
  ::RegistrationAck* _internal_mutable_reg_ack();
  public:
  void unsafe_arena_set_allocated_reg_ack(
      ::RegistrationAck* reg_ack);
  ::RegistrationAck* unsafe_arena_release_reg_ack();

  // .PduSessionAck pdu_ack = 3;
  bool has_pdu_ack() const;
  private:
  bool _internal_has_pdu_ack() const;
  public:
  void clear_pdu_ack();
  const ::PduSessionAck& pdu_ack() const;
  PROTOBUF_NODISCARD ::PduSessionAck* release_pdu_ack();
  ::PduSessionAck* mutable_pdu_ack();
  void set_allocated_pdu_ack(::PduSessionAck* pdu_ack);
  private:
  const ::PduSessionAck& _internal_pdu_ack() const;
  ::PduSessionAck* _internal_mutable_pdu_ack();
  public:
  void unsafe_arena_set_allocated_pdu_ack(
      ::PduSessionAck* pdu_ack);
  ::PduSessionAck* unsafe_arena_release_pdu_ack();

  // .DeregistrationAck dereg_ack = 4;
  bool has_dereg_ack() const;
  private:
  bool _internal_has_dereg_ack() const;
  public:
  void clear_dereg_ack();
  const ::DeregistrationAck& dereg_ack() const;
  PROTOBUF_NODISCARD ::DeregistrationAck* release_dereg_ack();
  ::DeregistrationAck* mutable_dereg_ack();
  void set_allocated_dereg_ack(::DeregistrationAck* dereg_ack);
  private:
  const ::DeregistrationAck& _internal_dereg_ack() const;
  ::DeregistrationAck* _internal_mutable_dereg_ack();
  public:
  void unsafe_arena_set_allocated_dereg_ack(
      ::DeregistrationAck* dereg_ack);
  ::DeregistrationAck* unsafe_arena_release_dereg_ack();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ServerMessage)
 private:
  class _Internal;
  void set_has_reg_ack();
  void set_has_pdu_ack();
  void set_has_dereg_ack();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::RegistrationAck* reg_ack_;
      ::PduSessionAck* pdu_ack_;
      ::DeregistrationAck* dereg_ack_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegistrationRequest

// int32 id = 1;
inline void RegistrationRequest::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t RegistrationRequest::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RegistrationRequest::id() const {
  // @@protoc_insertion_point(field_get:RegistrationRequest.id)
  return _internal_id();
}
inline void RegistrationRequest::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void RegistrationRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RegistrationRequest.id)
}

// -------------------------------------------------------------------

// RegistrationAck

// int32 id = 1;
inline void RegistrationAck::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t RegistrationAck::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RegistrationAck::id() const {
  // @@protoc_insertion_point(field_get:RegistrationAck.id)
  return _internal_id();
}
inline void RegistrationAck::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void RegistrationAck::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RegistrationAck.id)
}

// int32 status = 2;
inline void RegistrationAck::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t RegistrationAck::_internal_status() const {
  return _impl_.status_;
}
inline int32_t RegistrationAck::status() const {
  // @@protoc_insertion_point(field_get:RegistrationAck.status)
  return _internal_status();
}
inline void RegistrationAck::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void RegistrationAck::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:RegistrationAck.status)
}

// string status_message = 3;
inline void RegistrationAck::clear_status_message() {
  _impl_.status_message_.ClearToEmpty();
}
inline const std::string& RegistrationAck::status_message() const {
  // @@protoc_insertion_point(field_get:RegistrationAck.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegistrationAck::set_status_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegistrationAck.status_message)
}
inline std::string* RegistrationAck::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:RegistrationAck.status_message)
  return _s;
}
inline const std::string& RegistrationAck::_internal_status_message() const {
  return _impl_.status_message_.Get();
}
inline void RegistrationAck::_internal_set_status_message(const std::string& value) {
  
  _impl_.status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistrationAck::_internal_mutable_status_message() {
  
  return _impl_.status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* RegistrationAck::release_status_message() {
  // @@protoc_insertion_point(field_release:RegistrationAck.status_message)
  return _impl_.status_message_.Release();
}
inline void RegistrationAck::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    
  } else {
    
  }
  _impl_.status_message_.SetAllocated(status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_message_.IsDefault()) {
    _impl_.status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RegistrationAck.status_message)
}

// -------------------------------------------------------------------

// PduSessionRequest

// int32 id = 1;
inline void PduSessionRequest::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t PduSessionRequest::_internal_id() const {
  return _impl_.id_;
}
inline int32_t PduSessionRequest::id() const {
  // @@protoc_insertion_point(field_get:PduSessionRequest.id)
  return _internal_id();
}
inline void PduSessionRequest::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void PduSessionRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PduSessionRequest.id)
}

// int32 pdu_id = 2;
inline void PduSessionRequest::clear_pdu_id() {
  _impl_.pdu_id_ = 0;
}
inline int32_t PduSessionRequest::_internal_pdu_id() const {
  return _impl_.pdu_id_;
}
inline int32_t PduSessionRequest::pdu_id() const {
  // @@protoc_insertion_point(field_get:PduSessionRequest.pdu_id)
  return _internal_pdu_id();
}
inline void PduSessionRequest::_internal_set_pdu_id(int32_t value) {
  
  _impl_.pdu_id_ = value;
}
inline void PduSessionRequest::set_pdu_id(int32_t value) {
  _internal_set_pdu_id(value);
  // @@protoc_insertion_point(field_set:PduSessionRequest.pdu_id)
}

// int32 sst = 3;
inline void PduSessionRequest::clear_sst() {
  _impl_.sst_ = 0;
}
inline int32_t PduSessionRequest::_internal_sst() const {
  return _impl_.sst_;
}
inline int32_t PduSessionRequest::sst() const {
  // @@protoc_insertion_point(field_get:PduSessionRequest.sst)
  return _internal_sst();
}
inline void PduSessionRequest::_internal_set_sst(int32_t value) {
  
  _impl_.sst_ = value;
}
inline void PduSessionRequest::set_sst(int32_t value) {
  _internal_set_sst(value);
  // @@protoc_insertion_point(field_set:PduSessionRequest.sst)
}

// string sd = 4;
inline void PduSessionRequest::clear_sd() {
  _impl_.sd_.ClearToEmpty();
}
inline const std::string& PduSessionRequest::sd() const {
  // @@protoc_insertion_point(field_get:PduSessionRequest.sd)
  return _internal_sd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PduSessionRequest::set_sd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PduSessionRequest.sd)
}
inline std::string* PduSessionRequest::mutable_sd() {
  std::string* _s = _internal_mutable_sd();
  // @@protoc_insertion_point(field_mutable:PduSessionRequest.sd)
  return _s;
}
inline const std::string& PduSessionRequest::_internal_sd() const {
  return _impl_.sd_.Get();
}
inline void PduSessionRequest::_internal_set_sd(const std::string& value) {
  
  _impl_.sd_.Set(value, GetArenaForAllocation());
}
inline std::string* PduSessionRequest::_internal_mutable_sd() {
  
  return _impl_.sd_.Mutable(GetArenaForAllocation());
}
inline std::string* PduSessionRequest::release_sd() {
  // @@protoc_insertion_point(field_release:PduSessionRequest.sd)
  return _impl_.sd_.Release();
}
inline void PduSessionRequest::set_allocated_sd(std::string* sd) {
  if (sd != nullptr) {
    
  } else {
    
  }
  _impl_.sd_.SetAllocated(sd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sd_.IsDefault()) {
    _impl_.sd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PduSessionRequest.sd)
}

// -------------------------------------------------------------------

// PduSessionAck

// int32 id = 1;
inline void PduSessionAck::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t PduSessionAck::_internal_id() const {
  return _impl_.id_;
}
inline int32_t PduSessionAck::id() const {
  // @@protoc_insertion_point(field_get:PduSessionAck.id)
  return _internal_id();
}
inline void PduSessionAck::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void PduSessionAck::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PduSessionAck.id)
}

// int32 pdu_id = 2;
inline void PduSessionAck::clear_pdu_id() {
  _impl_.pdu_id_ = 0;
}
inline int32_t PduSessionAck::_internal_pdu_id() const {
  return _impl_.pdu_id_;
}
inline int32_t PduSessionAck::pdu_id() const {
  // @@protoc_insertion_point(field_get:PduSessionAck.pdu_id)
  return _internal_pdu_id();
}
inline void PduSessionAck::_internal_set_pdu_id(int32_t value) {
  
  _impl_.pdu_id_ = value;
}
inline void PduSessionAck::set_pdu_id(int32_t value) {
  _internal_set_pdu_id(value);
  // @@protoc_insertion_point(field_set:PduSessionAck.pdu_id)
}

// int32 status = 3;
inline void PduSessionAck::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t PduSessionAck::_internal_status() const {
  return _impl_.status_;
}
inline int32_t PduSessionAck::status() const {
  // @@protoc_insertion_point(field_get:PduSessionAck.status)
  return _internal_status();
}
inline void PduSessionAck::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void PduSessionAck::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:PduSessionAck.status)
}

// string status_message = 4;
inline void PduSessionAck::clear_status_message() {
  _impl_.status_message_.ClearToEmpty();
}
inline const std::string& PduSessionAck::status_message() const {
  // @@protoc_insertion_point(field_get:PduSessionAck.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PduSessionAck::set_status_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PduSessionAck.status_message)
}
inline std::string* PduSessionAck::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:PduSessionAck.status_message)
  return _s;
}
inline const std::string& PduSessionAck::_internal_status_message() const {
  return _impl_.status_message_.Get();
}
inline void PduSessionAck::_internal_set_status_message(const std::string& value) {
  
  _impl_.status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* PduSessionAck::_internal_mutable_status_message() {
  
  return _impl_.status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* PduSessionAck::release_status_message() {
  // @@protoc_insertion_point(field_release:PduSessionAck.status_message)
  return _impl_.status_message_.Release();
}
inline void PduSessionAck::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    
  } else {
    
  }
  _impl_.status_message_.SetAllocated(status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_message_.IsDefault()) {
    _impl_.status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PduSessionAck.status_message)
}

// -------------------------------------------------------------------

// DeregistrationRequest

// int32 id = 1;
inline void DeregistrationRequest::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t DeregistrationRequest::_internal_id() const {
  return _impl_.id_;
}
inline int32_t DeregistrationRequest::id() const {
  // @@protoc_insertion_point(field_get:DeregistrationRequest.id)
  return _internal_id();
}
inline void DeregistrationRequest::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void DeregistrationRequest::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DeregistrationRequest.id)
}

// -------------------------------------------------------------------

// DeregistrationAck

// int32 id = 1;
inline void DeregistrationAck::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t DeregistrationAck::_internal_id() const {
  return _impl_.id_;
}
inline int32_t DeregistrationAck::id() const {
  // @@protoc_insertion_point(field_get:DeregistrationAck.id)
  return _internal_id();
}
inline void DeregistrationAck::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void DeregistrationAck::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DeregistrationAck.id)
}

// int32 status = 2;
inline void DeregistrationAck::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t DeregistrationAck::_internal_status() const {
  return _impl_.status_;
}
inline int32_t DeregistrationAck::status() const {
  // @@protoc_insertion_point(field_get:DeregistrationAck.status)
  return _internal_status();
}
inline void DeregistrationAck::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void DeregistrationAck::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:DeregistrationAck.status)
}

// string status_message = 3;
inline void DeregistrationAck::clear_status_message() {
  _impl_.status_message_.ClearToEmpty();
}
inline const std::string& DeregistrationAck::status_message() const {
  // @@protoc_insertion_point(field_get:DeregistrationAck.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeregistrationAck::set_status_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeregistrationAck.status_message)
}
inline std::string* DeregistrationAck::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:DeregistrationAck.status_message)
  return _s;
}
inline const std::string& DeregistrationAck::_internal_status_message() const {
  return _impl_.status_message_.Get();
}
inline void DeregistrationAck::_internal_set_status_message(const std::string& value) {
  
  _impl_.status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeregistrationAck::_internal_mutable_status_message() {
  
  return _impl_.status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeregistrationAck::release_status_message() {
  // @@protoc_insertion_point(field_release:DeregistrationAck.status_message)
  return _impl_.status_message_.Release();
}
inline void DeregistrationAck::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    
  } else {
    
  }
  _impl_.status_message_.SetAllocated(status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_message_.IsDefault()) {
    _impl_.status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeregistrationAck.status_message)
}

// -------------------------------------------------------------------

// ClientMessage

// .MessageType type = 1;
inline void ClientMessage::clear_type() {
  _impl_.type_ = 0;
}
inline ::MessageType ClientMessage::_internal_type() const {
  return static_cast< ::MessageType >(_impl_.type_);
}
inline ::MessageType ClientMessage::type() const {
  // @@protoc_insertion_point(field_get:ClientMessage.type)
  return _internal_type();
}
inline void ClientMessage::_internal_set_type(::MessageType value) {
  
  _impl_.type_ = value;
}
inline void ClientMessage::set_type(::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ClientMessage.type)
}

// .RegistrationRequest reg_req = 2;
inline bool ClientMessage::_internal_has_reg_req() const {
  return payload_case() == kRegReq;
}
inline bool ClientMessage::has_reg_req() const {
  return _internal_has_reg_req();
}
inline void ClientMessage::set_has_reg_req() {
  _impl_._oneof_case_[0] = kRegReq;
}
inline void ClientMessage::clear_reg_req() {
  if (_internal_has_reg_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.reg_req_;
    }
    clear_has_payload();
  }
}
inline ::RegistrationRequest* ClientMessage::release_reg_req() {
  // @@protoc_insertion_point(field_release:ClientMessage.reg_req)
  if (_internal_has_reg_req()) {
    clear_has_payload();
    ::RegistrationRequest* temp = _impl_.payload_.reg_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.reg_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RegistrationRequest& ClientMessage::_internal_reg_req() const {
  return _internal_has_reg_req()
      ? *_impl_.payload_.reg_req_
      : reinterpret_cast< ::RegistrationRequest&>(::_RegistrationRequest_default_instance_);
}
inline const ::RegistrationRequest& ClientMessage::reg_req() const {
  // @@protoc_insertion_point(field_get:ClientMessage.reg_req)
  return _internal_reg_req();
}
inline ::RegistrationRequest* ClientMessage::unsafe_arena_release_reg_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientMessage.reg_req)
  if (_internal_has_reg_req()) {
    clear_has_payload();
    ::RegistrationRequest* temp = _impl_.payload_.reg_req_;
    _impl_.payload_.reg_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_reg_req(::RegistrationRequest* reg_req) {
  clear_payload();
  if (reg_req) {
    set_has_reg_req();
    _impl_.payload_.reg_req_ = reg_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientMessage.reg_req)
}
inline ::RegistrationRequest* ClientMessage::_internal_mutable_reg_req() {
  if (!_internal_has_reg_req()) {
    clear_payload();
    set_has_reg_req();
    _impl_.payload_.reg_req_ = CreateMaybeMessage< ::RegistrationRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.reg_req_;
}
inline ::RegistrationRequest* ClientMessage::mutable_reg_req() {
  ::RegistrationRequest* _msg = _internal_mutable_reg_req();
  // @@protoc_insertion_point(field_mutable:ClientMessage.reg_req)
  return _msg;
}

// .PduSessionRequest pdu_req = 3;
inline bool ClientMessage::_internal_has_pdu_req() const {
  return payload_case() == kPduReq;
}
inline bool ClientMessage::has_pdu_req() const {
  return _internal_has_pdu_req();
}
inline void ClientMessage::set_has_pdu_req() {
  _impl_._oneof_case_[0] = kPduReq;
}
inline void ClientMessage::clear_pdu_req() {
  if (_internal_has_pdu_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.pdu_req_;
    }
    clear_has_payload();
  }
}
inline ::PduSessionRequest* ClientMessage::release_pdu_req() {
  // @@protoc_insertion_point(field_release:ClientMessage.pdu_req)
  if (_internal_has_pdu_req()) {
    clear_has_payload();
    ::PduSessionRequest* temp = _impl_.payload_.pdu_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.pdu_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PduSessionRequest& ClientMessage::_internal_pdu_req() const {
  return _internal_has_pdu_req()
      ? *_impl_.payload_.pdu_req_
      : reinterpret_cast< ::PduSessionRequest&>(::_PduSessionRequest_default_instance_);
}
inline const ::PduSessionRequest& ClientMessage::pdu_req() const {
  // @@protoc_insertion_point(field_get:ClientMessage.pdu_req)
  return _internal_pdu_req();
}
inline ::PduSessionRequest* ClientMessage::unsafe_arena_release_pdu_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientMessage.pdu_req)
  if (_internal_has_pdu_req()) {
    clear_has_payload();
    ::PduSessionRequest* temp = _impl_.payload_.pdu_req_;
    _impl_.payload_.pdu_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_pdu_req(::PduSessionRequest* pdu_req) {
  clear_payload();
  if (pdu_req) {
    set_has_pdu_req();
    _impl_.payload_.pdu_req_ = pdu_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientMessage.pdu_req)
}
inline ::PduSessionRequest* ClientMessage::_internal_mutable_pdu_req() {
  if (!_internal_has_pdu_req()) {
    clear_payload();
    set_has_pdu_req();
    _impl_.payload_.pdu_req_ = CreateMaybeMessage< ::PduSessionRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.pdu_req_;
}
inline ::PduSessionRequest* ClientMessage::mutable_pdu_req() {
  ::PduSessionRequest* _msg = _internal_mutable_pdu_req();
  // @@protoc_insertion_point(field_mutable:ClientMessage.pdu_req)
  return _msg;
}

// .DeregistrationRequest dereg_req = 4;
inline bool ClientMessage::_internal_has_dereg_req() const {
  return payload_case() == kDeregReq;
}
inline bool ClientMessage::has_dereg_req() const {
  return _internal_has_dereg_req();
}
inline void ClientMessage::set_has_dereg_req() {
  _impl_._oneof_case_[0] = kDeregReq;
}
inline void ClientMessage::clear_dereg_req() {
  if (_internal_has_dereg_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.dereg_req_;
    }
    clear_has_payload();
  }
}
inline ::DeregistrationRequest* ClientMessage::release_dereg_req() {
  // @@protoc_insertion_point(field_release:ClientMessage.dereg_req)
  if (_internal_has_dereg_req()) {
    clear_has_payload();
    ::DeregistrationRequest* temp = _impl_.payload_.dereg_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.dereg_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DeregistrationRequest& ClientMessage::_internal_dereg_req() const {
  return _internal_has_dereg_req()
      ? *_impl_.payload_.dereg_req_
      : reinterpret_cast< ::DeregistrationRequest&>(::_DeregistrationRequest_default_instance_);
}
inline const ::DeregistrationRequest& ClientMessage::dereg_req() const {
  // @@protoc_insertion_point(field_get:ClientMessage.dereg_req)
  return _internal_dereg_req();
}
inline ::DeregistrationRequest* ClientMessage::unsafe_arena_release_dereg_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientMessage.dereg_req)
  if (_internal_has_dereg_req()) {
    clear_has_payload();
    ::DeregistrationRequest* temp = _impl_.payload_.dereg_req_;
    _impl_.payload_.dereg_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_dereg_req(::DeregistrationRequest* dereg_req) {
  clear_payload();
  if (dereg_req) {
    set_has_dereg_req();
    _impl_.payload_.dereg_req_ = dereg_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientMessage.dereg_req)
}
inline ::DeregistrationRequest* ClientMessage::_internal_mutable_dereg_req() {
  if (!_internal_has_dereg_req()) {
    clear_payload();
    set_has_dereg_req();
    _impl_.payload_.dereg_req_ = CreateMaybeMessage< ::DeregistrationRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.dereg_req_;
}
inline ::DeregistrationRequest* ClientMessage::mutable_dereg_req() {
  ::DeregistrationRequest* _msg = _internal_mutable_dereg_req();
  // @@protoc_insertion_point(field_mutable:ClientMessage.dereg_req)
  return _msg;
}

inline bool ClientMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientMessage::PayloadCase ClientMessage::payload_case() const {
  return ClientMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .MessageType type = 1;
inline void ServerMessage::clear_type() {
  _impl_.type_ = 0;
}
inline ::MessageType ServerMessage::_internal_type() const {
  return static_cast< ::MessageType >(_impl_.type_);
}
inline ::MessageType ServerMessage::type() const {
  // @@protoc_insertion_point(field_get:ServerMessage.type)
  return _internal_type();
}
inline void ServerMessage::_internal_set_type(::MessageType value) {
  
  _impl_.type_ = value;
}
inline void ServerMessage::set_type(::MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ServerMessage.type)
}

// .RegistrationAck reg_ack = 2;
inline bool ServerMessage::_internal_has_reg_ack() const {
  return payload_case() == kRegAck;
}
inline bool ServerMessage::has_reg_ack() const {
  return _internal_has_reg_ack();
}
inline void ServerMessage::set_has_reg_ack() {
  _impl_._oneof_case_[0] = kRegAck;
}
inline void ServerMessage::clear_reg_ack() {
  if (_internal_has_reg_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.reg_ack_;
    }
    clear_has_payload();
  }
}
inline ::RegistrationAck* ServerMessage::release_reg_ack() {
  // @@protoc_insertion_point(field_release:ServerMessage.reg_ack)
  if (_internal_has_reg_ack()) {
    clear_has_payload();
    ::RegistrationAck* temp = _impl_.payload_.reg_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.reg_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RegistrationAck& ServerMessage::_internal_reg_ack() const {
  return _internal_has_reg_ack()
      ? *_impl_.payload_.reg_ack_
      : reinterpret_cast< ::RegistrationAck&>(::_RegistrationAck_default_instance_);
}
inline const ::RegistrationAck& ServerMessage::reg_ack() const {
  // @@protoc_insertion_point(field_get:ServerMessage.reg_ack)
  return _internal_reg_ack();
}
inline ::RegistrationAck* ServerMessage::unsafe_arena_release_reg_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.reg_ack)
  if (_internal_has_reg_ack()) {
    clear_has_payload();
    ::RegistrationAck* temp = _impl_.payload_.reg_ack_;
    _impl_.payload_.reg_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_reg_ack(::RegistrationAck* reg_ack) {
  clear_payload();
  if (reg_ack) {
    set_has_reg_ack();
    _impl_.payload_.reg_ack_ = reg_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.reg_ack)
}
inline ::RegistrationAck* ServerMessage::_internal_mutable_reg_ack() {
  if (!_internal_has_reg_ack()) {
    clear_payload();
    set_has_reg_ack();
    _impl_.payload_.reg_ack_ = CreateMaybeMessage< ::RegistrationAck >(GetArenaForAllocation());
  }
  return _impl_.payload_.reg_ack_;
}
inline ::RegistrationAck* ServerMessage::mutable_reg_ack() {
  ::RegistrationAck* _msg = _internal_mutable_reg_ack();
  // @@protoc_insertion_point(field_mutable:ServerMessage.reg_ack)
  return _msg;
}

// .PduSessionAck pdu_ack = 3;
inline bool ServerMessage::_internal_has_pdu_ack() const {
  return payload_case() == kPduAck;
}
inline bool ServerMessage::has_pdu_ack() const {
  return _internal_has_pdu_ack();
}
inline void ServerMessage::set_has_pdu_ack() {
  _impl_._oneof_case_[0] = kPduAck;
}
inline void ServerMessage::clear_pdu_ack() {
  if (_internal_has_pdu_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.pdu_ack_;
    }
    clear_has_payload();
  }
}
inline ::PduSessionAck* ServerMessage::release_pdu_ack() {
  // @@protoc_insertion_point(field_release:ServerMessage.pdu_ack)
  if (_internal_has_pdu_ack()) {
    clear_has_payload();
    ::PduSessionAck* temp = _impl_.payload_.pdu_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.pdu_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PduSessionAck& ServerMessage::_internal_pdu_ack() const {
  return _internal_has_pdu_ack()
      ? *_impl_.payload_.pdu_ack_
      : reinterpret_cast< ::PduSessionAck&>(::_PduSessionAck_default_instance_);
}
inline const ::PduSessionAck& ServerMessage::pdu_ack() const {
  // @@protoc_insertion_point(field_get:ServerMessage.pdu_ack)
  return _internal_pdu_ack();
}
inline ::PduSessionAck* ServerMessage::unsafe_arena_release_pdu_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.pdu_ack)
  if (_internal_has_pdu_ack()) {
    clear_has_payload();
    ::PduSessionAck* temp = _impl_.payload_.pdu_ack_;
    _impl_.payload_.pdu_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_pdu_ack(::PduSessionAck* pdu_ack) {
  clear_payload();
  if (pdu_ack) {
    set_has_pdu_ack();
    _impl_.payload_.pdu_ack_ = pdu_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.pdu_ack)
}
inline ::PduSessionAck* ServerMessage::_internal_mutable_pdu_ack() {
  if (!_internal_has_pdu_ack()) {
    clear_payload();
    set_has_pdu_ack();
    _impl_.payload_.pdu_ack_ = CreateMaybeMessage< ::PduSessionAck >(GetArenaForAllocation());
  }
  return _impl_.payload_.pdu_ack_;
}
inline ::PduSessionAck* ServerMessage::mutable_pdu_ack() {
  ::PduSessionAck* _msg = _internal_mutable_pdu_ack();
  // @@protoc_insertion_point(field_mutable:ServerMessage.pdu_ack)
  return _msg;
}

// .DeregistrationAck dereg_ack = 4;
inline bool ServerMessage::_internal_has_dereg_ack() const {
  return payload_case() == kDeregAck;
}
inline bool ServerMessage::has_dereg_ack() const {
  return _internal_has_dereg_ack();
}
inline void ServerMessage::set_has_dereg_ack() {
  _impl_._oneof_case_[0] = kDeregAck;
}
inline void ServerMessage::clear_dereg_ack() {
  if (_internal_has_dereg_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.dereg_ack_;
    }
    clear_has_payload();
  }
}
inline ::DeregistrationAck* ServerMessage::release_dereg_ack() {
  // @@protoc_insertion_point(field_release:ServerMessage.dereg_ack)
  if (_internal_has_dereg_ack()) {
    clear_has_payload();
    ::DeregistrationAck* temp = _impl_.payload_.dereg_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.dereg_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DeregistrationAck& ServerMessage::_internal_dereg_ack() const {
  return _internal_has_dereg_ack()
      ? *_impl_.payload_.dereg_ack_
      : reinterpret_cast< ::DeregistrationAck&>(::_DeregistrationAck_default_instance_);
}
inline const ::DeregistrationAck& ServerMessage::dereg_ack() const {
  // @@protoc_insertion_point(field_get:ServerMessage.dereg_ack)
  return _internal_dereg_ack();
}
inline ::DeregistrationAck* ServerMessage::unsafe_arena_release_dereg_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ServerMessage.dereg_ack)
  if (_internal_has_dereg_ack()) {
    clear_has_payload();
    ::DeregistrationAck* temp = _impl_.payload_.dereg_ack_;
    _impl_.payload_.dereg_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_dereg_ack(::DeregistrationAck* dereg_ack) {
  clear_payload();
  if (dereg_ack) {
    set_has_dereg_ack();
    _impl_.payload_.dereg_ack_ = dereg_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerMessage.dereg_ack)
}
inline ::DeregistrationAck* ServerMessage::_internal_mutable_dereg_ack() {
  if (!_internal_has_dereg_ack()) {
    clear_payload();
    set_has_dereg_ack();
    _impl_.payload_.dereg_ack_ = CreateMaybeMessage< ::DeregistrationAck >(GetArenaForAllocation());
  }
  return _impl_.payload_.dereg_ack_;
}
inline ::DeregistrationAck* ServerMessage::mutable_dereg_ack() {
  ::DeregistrationAck* _msg = _internal_mutable_dereg_ack();
  // @@protoc_insertion_point(field_mutable:ServerMessage.dereg_ack)
  return _msg;
}

inline bool ServerMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerMessage::PayloadCase ServerMessage::payload_case() const {
  return ServerMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
